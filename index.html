<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake — JS Game</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#22c55e;--muted:#94a3b8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071025 0%,#081827 100%);color:#e6eef8}
    .wrap{width:min(900px,96vw);max-width:900px;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 30px rgba(2,6,23,0.7)}
    header{display:flex;align-items:center;gap:12px}
    h1{margin:0;font-size:20px}
    .hud{display:flex;gap:12px;margin-top:12px;align-items:center}
    .pill{background:var(--card);padding:8px 12px;border-radius:10px;color:var(--muted);font-size:14px}
    .pill strong{color:var(--accent);font-weight:700;margin-right:6px}
    canvas{display:block;margin:14px auto;border-radius:10px;background:#071425;width:100%;height:60vmin;max-height:600px;box-shadow:inset 0 0 40px rgba(0,0,0,0.6)}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.primary{border-color:var(--accent);color:var(--accent)}
    footer{margin-top:12px;font-size:13px;color:var(--muted)}
    .small{font-size:13px;color:var(--muted)}
    @media (max-width:520px){canvas{height:70vmin}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Snake — JavaScript Game</h1>
      <div class="small">Grid-based classic. Responsive, keyboard & touch controls, persistent high score.</div>
    </header>

    <div class="hud">
      <div class="pill">Score: <strong id="score">0</strong></div>
      <div class="pill">High: <strong id="high">0</strong></div>
      <div class="pill">Speed: <strong id="speedLabel">Medium</strong></div>
    </div>

    <canvas id="game"></canvas>

    <div class="controls">
      <button id="startBtn" class="primary">Start / Restart</button>
      <button id="pauseBtn">Pause</button>
      <label class="pill">Speed:
        <select id="speedSelect">
          <option value="6">Slow</option>
          <option value="9" selected>Medium</option>
          <option value="13">Fast</option>
        </select>
      </label>
      <div class="small">Controls: Arrow keys / WASD. On touch, swipe to turn.</div>
    </div>

    <footer>
      <div class="small">Built with plain HTML/CSS/JS — works offline. Your high score is stored locally.</div>
    </footer>
  </div>

<script>
(() => {
  // Config
  const CELL = 20; // base cell size in CSS pixels; canvas is scaled by DPR
  const STORAGE_KEY = 'snake_high_score_v1';

  // DOM
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedSelect = document.getElementById('speedSelect');
  const speedLabel = document.getElementById('speedLabel');

  // State
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let gridCols = 20; // will be recalculated on resize
  let gridRows = 20;
  let cellSize = CELL;
  let lastTime = 0;
  let accumulator = 0;
  let tickRate = 9; // moves per second
  let running = false;
  let paused = false;

  let snake = [{x:10,y:10}];
  let dir = {x:1,y:0};
  let nextDir = null;
  let food = null;
  let score = 0;
  let high = parseInt(localStorage.getItem(STORAGE_KEY) || '0', 10) || 0;

  highEl.textContent = high;
  scoreEl.textContent = score;

  // Audio helper (tiny blip)
  function blip(freq=440, duration=0.06) {
    try{
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.value = 0.02;
      o.connect(g); g.connect(ac.destination);
      o.start();
      setTimeout(()=>{ o.stop(); ac.close(); }, duration*1000);
    }catch(e){/*ignore audio errors*/}
  }

  // Resize & grid calculation
  function resize() {
    const rect = canvas.getBoundingClientRect();
    // choose grid so cells fit nicely depending on width
    const cssWidth = rect.width;
    gridCols = Math.floor(cssWidth / CELL);
    gridRows = Math.floor((rect.height || (cssWidth * 0.6)) / CELL);
    cellSize = Math.floor(cssWidth / gridCols);

    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor((cellSize * gridRows) * dpr);
    canvas.style.height = `${cellSize * gridRows}px`;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }

  window.addEventListener('resize', () => { resize(); });

  // Game helpers
  function randCell() {
    return { x: Math.floor(Math.random()*gridCols), y: Math.floor(Math.random()*gridRows) };
  }

  function placeFood() {
    let tries = 0;
    do {
      food = randCell();
      tries++;
    } while (snake.some(p => p.x===food.x && p.y===food.y) && tries < 1000);
  }

  function startGame() {
    // center snake
    gridCols = Math.max(8, gridCols);
    gridRows = Math.max(8, gridRows);
    snake = [{x: Math.floor(gridCols/2), y: Math.floor(gridRows/2)}];
    dir = {x:1,y:0}; nextDir = null;
    score = 0; scoreEl.textContent = score;
    tickRate = parseInt(speedSelect.value,10) || 9;
    updateSpeedLabel();
    placeFood();
    running = true; paused = false;
    lastTime = performance.now(); accumulator = 0;
    blip(660, 0.03);
    requestAnimationFrame(loop);
  }

  function endGame() {
    running = false;
    blip(160, 0.18);
    if (score > high){
      high = score; localStorage.setItem(STORAGE_KEY, String(high)); highEl.textContent = high;
    }
    // small flash effect
    flashScreen();
  }

  function flashScreen(){
    const save = ctx.fillStyle;
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);
    ctx.fillStyle = save;
  }

  function update(dt) {
    if (nextDir) { dir = nextDir; nextDir = null; }
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };
    head.x = (head.x + gridCols) % gridCols;
    head.y = (head.y + gridRows) % gridRows;

    if (snake.some((p,i)=> i>0 && p.x===head.x && p.y===head.y)){
      endGame();
      return;
    }

    snake.unshift(head);

    // eat food?
    if (food && head.x===food.x && head.y===food.y) {
      score += 1;
      scoreEl.textContent = score;
      blip(880,0.05);
      placeFood();
    } else {
      snake.pop(); // remove tail
    }
  }

  function drawGrid() {
    const w = canvas.width/dpr; const h = canvas.height/dpr;
    ctx.clearRect(0,0,w,h);
    // subtle grid
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let x=0;x<=gridCols;x++){
      ctx.beginPath(); ctx.moveTo(x*cellSize+0.5,0); ctx.lineTo(x*cellSize+0.5,h); ctx.stroke();
    }
    for (let y=0;y<=gridRows;y++){
      ctx.beginPath(); ctx.moveTo(0,y*cellSize+0.5); ctx.lineTo(w,y*cellSize+0.5); ctx.stroke();
    }
  }

  function draw() {
    drawGrid();
    // draw food
    if (food){
      drawCell(food.x, food.y, '#ef4444', true);
    }
    // draw snake
    for (let i=snake.length-1;i>=0;i--){
      const p = snake[i];
      const shade = i===0 ? '#22c55e' : '#16a34a';
      drawCell(p.x, p.y, shade, i===0);
    }
  }

  function drawCell(cx, cy, color, filled){
    const x = cx*cellSize+1; const y = cy*cellSize+1;
    const s = Math.max(0, cellSize-2);
    ctx.save();
    ctx.fillStyle = color;
    if (filled) {
      // head with highlight
      ctx.fillRect(x,y,s,s);
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(x+2,y+2,Math.max(0,s-4),Math.max(0,s-4));
    } else {
      ctx.fillRect(x,y,s,s);
    }
    ctx.restore();
  }

  // Main loop using fixed tick step for consistent snake movement
  function loop(now) {
    if (!running) { draw(); return; }
    if (paused) { draw(); requestAnimationFrame(loop); return; }
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    accumulator += dt;
    const step = 1 / tickRate;
    while (accumulator >= step){
      update(step);
      accumulator -= step;
    }
    draw();
    requestAnimationFrame(loop);
  }

  // input handling
  function setDirection(x,y){
    // prevent reversing
    if (x === -dir.x && y === -dir.y) return;
    // queue for next tick to avoid multiple turns in same frame
    nextDir = {x,y};
  }

  window.addEventListener('keydown', (e) => {
    if (!running && (e.key === ' ' || e.key === 'Enter')) { startGame(); return; }
    if (e.key === 'p'){ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; return; }
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)){
      e.preventDefault();
      switch(e.key){
        case 'ArrowUp': case 'w': case 'W': setDirection(0,-1); break;
        case 'ArrowDown': case 's': case 'S': setDirection(0,1); break;
        case 'ArrowLeft': case 'a': case 'A': setDirection(-1,0); break;
        case 'ArrowRight': case 'd': case 'D': setDirection(1,0); break;
      }
    }
  });

  // Touch swipe support (simple)
  let touchStart = null;
  canvas.addEventListener('touchstart', (e)=>{
    const t = e.touches[0]; touchStart = {x: t.clientX, y: t.clientY};
  }, {passive:true});
  canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchend', (e)=>{
    if(!touchStart) return; const t = e.changedTouches[0]; const dx = t.clientX - touchStart.x; const dy = t.clientY - touchStart.y;
    const absX = Math.abs(dx), absY = Math.abs(dy);
    if(Math.max(absX,absY) < 20) { touchStart = null; return; }
    if(absX > absY) setDirection(dx>0?1: -1, 0); else setDirection(0, dy>0?1:-1);
    touchStart = null;
  }, {passive:true});

  // UI buttons
  startBtn.addEventListener('click', ()=> startGame());
  pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; });
  speedSelect.addEventListener('change', ()=>{ tickRate = parseInt(speedSelect.value,10); updateSpeedLabel(); });

  function updateSpeedLabel(){
    const map = {6:'Slow', 9:'Medium', 13:'Fast'}; speedLabel.textContent = map[speedSelect.value] || String(speedSelect.value);
    // change tickRate immediately
    tickRate = parseInt(speedSelect.value,10);
  }

  // Prevent accidental two-finger zoom on mobile inside canvas
  canvas.addEventListener('gesturestart', e=>e.preventDefault());

  // init
  function init(){
    // set CSS canvas height in pixels (we'll compute rows based on width); a parent CSS controls width
    resize();
    // start drawing static frame
    draw();
  }

  init();
})();
</script>
</body>
</html>
